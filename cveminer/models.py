import subprocess
import os
import json
import copy
import re

import gitlogparser.parser as gitParser
import cvemanager.cve_manager as cveManager
import cvemanager.cve_dbms as database

from gitlogparser.models import CommitData
from gitlogparser.models import Author

class GitExtractor(object):
    def __init__(self):
        self.logs = list()
        # this is where the repositories will be cloned
        self.repo_path = './repos'
        self.baseDir = os.getcwd()

    def get_online_logs(self, target_url):
        self.download_repo(target_url)
        # prep the directory, since download repo already enters the repo path, it doesn't need to be added
        directory = './' + target_url.split('/')[-1]
        if os.path.isdir(directory):
            return self.get_local_logs(directory)
        else:
            os.chdir(self.baseDir)
            raise FileNotFoundError('The specified directory couldn\'t be downloaded.')

    def get_local_logs(self, target_path):
        # create a dummy class to simulate console argument
        class DummyArgs(object):
            def __init__(self, dir):
                self.directory = dir
        if os.path.isdir(target_path):
            try:
            # parse the git logs
                gitParser.get_log(DummyArgs(target_path))
            # read the git logs
                if os.path.isfile('logdata_new.json'):
                    with open('logdata_new.json', 'r', encoding='utf-8') as f:
                        self.logs = json.load(f)
            # remove the temporary json file
                    print('Removing json')
                    os.remove('logdata_new.json')
                os.chdir(self.baseDir)
                return self.logs
            except Exception as ex:
                os.chdir(self.baseDir)
                print(ex)

        else:
            raise FileNotFoundError('The specified directory doesn\'t exist!')

    def download_repo(self, target_url):
        # try to open the repo path, if it fails, create a new directory
        try:
            os.chdir(self.repo_path)
        except FileNotFoundError:
            os.mkdir(self.repo_path)
            os.chdir(self.repo_path)

        # clone the requested url
        subprocess.run(['git', 'clone', target_url])


class CveManager(object):
    def __init__(self):
        self.cve_dir = None
        self.csv_dir = None
        self.user = None
        self.host = None
        self.name = None
        self.owner = None
        self.password = None

    def read_settings(self):
        with open('settings.json', 'r') as f:
            settings = json.load(f)
            self.cve_dir = settings["paths"]["cve_path"]
            self.csv_dir = settings["paths"]["csv_path"]
            self.user = settings['database']['user']
            self.host = settings['database']['host']
            self.name = settings['database']['name']
            self.owner = settings['database']['owner']
            self.password = input('Enter password for %s: ' % settings['database']['user'])

    def setup_cves(self):
        self.read_settings()
        cveManager.download_cves(self.cve_dir, False)
        cveManager.process_cves(self.cve_dir, self.csv_dir, True)

    def setup_database(self):
        self.read_settings()
        database.create_database(self.user, self.password, self.host, self.name, self.owner)
        database.create_tables(self.user, self.password, self.host, self.name)
        database.import_database(self.csv_dir, self.user, self.password, self.host, self.name)

    def get_cve(self, cve_id):
        selected_cve = None
        if self.password is None:
            self.read_settings()
        selected_cve = database.execute_query(self.user, self.password, self.host, self.name, cve_id, 0, 0, False)
        return selected_cve

# class to store data about found cve
class CveData(object):
    def __init__(self, foundCommit = None, fixCommit = None):
        self.foundCommit = foundCommit
        self.fixCommit = fixCommit

    def __str__(self):
        return f'start commit: {self.foundCommit}, fixing commit: {self.fixCommit}'

class CommitClassifier(object):
    def __init__(self):
        self.cve_id_pattern = re.compile(r'.*(CVE|cve)\-([0-9]{4})\-([0-9]{4})')

    def get_cve_commits(self, commits):
        cve_commits = dict()
        # look through mined commits and collect every cve
        for commit in commits:
            if self.cve_id_pattern.search(commit['message']):
                cve = self.cve_id_pattern.search(commit['message']).group(0).upper()
                # if a cve only appears once it is assumed to be a fix
                if cve not in cve_commits.keys():
                    cve_commits[cve] = CveData(commit, commit)
                else:
                    cve_commits[cve].fixCommit = commit
        
        return cve_commits
